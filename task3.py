import networkx as nx
import heapq

# Створюємо порожній граф
G = nx.Graph()

# Додаємо вузли для всіх трьох ліній
stations = [
    # Червона лінія (Святошинсько-Броварська)
    "Академмістечко", "Житомирська", "Святошин", "Нивки", "Берестейська", 
    "Шулявська", "Політехнічний інститут", "Вокзальна", "Університет", "Театральна",
    "Хрещатик", "Арсенальна", "Дніпро", "Гідропарк", "Лівобережна", "Дарниця",
    "Чернігівська", "Лісова",
    # Синя лінія (Куренівсько-Червоноармійська)
    "Героїв Дніпра", "Мінська", "Оболонь", "Почайна", "Тараса Шевченка", 
    "Контрактова площа", "Поштова площа", "Майдан Незалежності", 
    "Площа Льва Толстого", "Олімпійська", "Палац Україна", "Либідська", 
    "Деміївська", "Голосіївська", "Васильківська", "Виставковий центр", 
    "Іподром", "Теремки",
    # Зелена лінія (Сирецько-Печерська)
    "Сирець", "Дорогожичі", "Лук'янівська", "Золоті ворота", "Палац Спорту", 
    "Кловська", "Печерська", "Дружби народів", "Видубичі", "Славутич", 
    "Осокорки", "Позняки", "Харківська", "Вирлиця", "Бориспільська", 
    "Червоний Хутір"
]

# Додаємо станції до графа
G.add_nodes_from(stations)

# Додаємо ребра для всіх трьох ліній
red_line_edges = [
    ("Академмістечко", "Житомирська"), 
    ("Житомирська", "Святошин"), 
    ("Святошин", "Нивки"), 
    ("Нивки", "Берестейська"),
    ("Берестейська", "Шулявська"), 
    ("Шулявська", "Політехнічний інститут"), 
    ("Політехнічний інститут", "Вокзальна"),
    ("Вокзальна", "Університет"),
    ("Університет", "Театральна"), 
    ("Театральна", "Хрещатик"), 
    ("Хрещатик", "Арсенальна"), 
    ("Арсенальна", "Дніпро"),
    ("Дніпро", "Гідропарк"), 
    ("Гідропарк", "Лівобережна"), 
    ("Лівобережна", "Дарниця"), 
    ("Дарниця", "Чернігівська"),
    ("Чернігівська", "Лісова")
]

blue_line_edges = [
    ("Героїв Дніпра", "Мінська"),
    ("Мінська", "Оболонь"),
    ("Оболонь", "Почайна"),
    ("Почайна", "Тараса Шевченка"),
    ("Тараса Шевченка", "Контрактова площа"),
    ("Контрактова площа", "Поштова площа"),
    ("Поштова площа", "Майдан Незалежності"),
    ("Майдан Незалежності", "Площа Льва Толстого"),
    ("Площа Льва Толстого", "Олімпійська"),
    ("Олімпійська", "Палац Україна"),
    ("Палац Україна", "Либідська"),
    ("Либідська", "Деміївська"),
    ("Деміївська", "Голосіївська"),
    ("Голосіївська", "Васильківська"),
    ("Васильківська", "Виставковий центр"),
    ("Виставковий центр", "Іподром"),
    ("Іподром", "Теремки")
]

green_line_edges = [
    ("Сирець", "Дорогожичі"),
    ("Дорогожичі", "Лук'янівська"),
    ("Лук'янівська", "Золоті ворота"),
    ("Золоті ворота", "Палац Спорту"),
    ("Палац Спорту", "Кловська"),
    ("Кловська", "Печерська"),
    ("Печерська", "Дружби народів"),
    ("Дружби народів", "Видубичі"),
    ("Видубичі", "Славутич"),
    ("Славутич", "Осокорки"),
    ("Осокорки", "Позняки"),
    ("Позняки", "Харківська"),
    ("Харківська", "Вирлиця"),
    ("Вирлиця", "Бориспільська"),
    ("Бориспільська", "Червоний Хутір")
]

# Додаємо ребра до графа з вагою
standard_weight = 1
transfer_weight = 2

G.add_weighted_edges_from([(u, v, standard_weight) for u, v in red_line_edges])
G.add_weighted_edges_from([(u, v, standard_weight) for u, v in blue_line_edges])
G.add_weighted_edges_from([(u, v, standard_weight) for u, v in green_line_edges])

# Додаємо пересадки між лініями з більшою вагою
transfer_edges = [
    ("Театральна", "Золоті ворота"),
    ("Хрещатик", "Майдан Незалежності"),
    ("Площа Льва Толстого", "Палац Спорту")
]

G.add_weighted_edges_from([(u, v, transfer_weight) for u, v in transfer_edges])

# Реалізація алгоритму Дейкстри
def dijkstra_nx(graph, start_vertex):
    # Ініціалізація відстаней до всіх вершин як нескінченність
    distances = {vertex: float('infinity') for vertex in graph.nodes}
    distances[start_vertex] = 0

    # Пріоритетна черга для пошуку найближчої вершини
    priority_queue = [(0, start_vertex)]
    
    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)

        # Якщо знайдена відстань більша за вже відому, то продовжуємо
        if current_distance > distances[current_vertex]:
            continue

        # Оновлення відстаней до сусідніх вершин
        for neighbor in graph.neighbors(current_vertex):
            weight = graph[current_vertex][neighbor]['weight']
            distance = current_distance + weight

            # Якщо знайдена коротша відстань, то оновлюємо її
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances

# Знаходимо найкоротший шлях від 'Академмістечко' до всіх інших станцій
shortest_paths = dijkstra_nx(G, 'Академмістечко')

# Виведення результатів
for destination, distance in shortest_paths.items():
    print(f"Найкоротший шлях від Академмістечко до {destination}: {distance}")
